<sect1 id="zend.search.lucene.overview">
    <title>Vue d'ensemble</title>

    <sect2 id="zend.search.lucene.introduction">
        <title>Introduction</title>
        <para>
            Zend_Search_Lucene est un moteur de recherche textuel général totalement écrit en PHP 5.
            Bien qu'il stocke ses index dans le système de fichiers, et ne nécessite pas de base de données,
            il peut ajouter des capacités de recherche sur presque tous les sites PHP utilisant une base de données.

            Zend_Search_Lucene supporte les fonctionnalités suivantes :
            <itemizedlist>
                <listitem>
                    <para>Recherche par pertinence - les meilleurs résultats sont retournés en premier</para>
                </listitem>
                <listitem>
                    <para>
                       Beaucoup de type de puissantes recherche :
                         recherche sur des phrases,
                         recherche joker,
                         recherche de proximité,
                         recherche par intervalle
                         et bien plus
                        <footnote>
                           <para>
                             Les recherches par mots, par groupes de mots, par phrase, les expressions booléennes et sous-requêtes sont supportées pour le moment.
                           </para>
                        </footnote>
                    </para>
                </listitem>
                <listitem>
                    <para>Recherche par champs spécifiques (par exemple , titre, auteur, contenu)</para>
                </listitem>
            </itemizedlist>

            Zend_Search_Lucene est dérivé du projet Apache Lucene. La version courante supportée de Lucene est la 2.0.
            Pour plus d'informations vous pouvez visiter <ulink url="http://lucene.apache.org/java/docs/"/> (<ulink url="http://lucene.apache.org/java/2_0_0/"/>).
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.documents-and-fields">
        <title>Objets document et champ</title>
            <para>
                Zend_Search_Lucene considère les documents comme des sujets atomiques pour l'indexation.
                Un document est divisé en champs nommés, et les champs ont du contenu dans lequel on peut rechercher.
            </para>

            <para>
                Un document est représenté par l'objet Zend_Search_Lucene_Document,
                et cet objet contient des objets Zend_Search_Lucene_Field qui représentent les champs.
            </para>

            <para>
                Il est important de noter que toute sorte d'information peut être ajoutée à l'index.
                Les informations spécifiques à l'application, ou les métadonnées peuvent être stockées
                dans les champs du document, et retrouvées ensuite pendant la recherche.
            </para>

            <para>
                Il est de votre responsabilité de contrôler l'indexeur.
                Cela signifie que les données peuvent-être indexées à partir de n'importe
                quelle source accessible par votre application.
                Cela peut-être aussi bien le système de fichiers, qu'une base de données,
                qu'un formulaire HTML, etc.
            </para>

            <para>
                La classe <code>Zend_Search_Lucene_Field</code> fournit plusieurs méthodes statiques pour créer
                des champs de différentes caractéristiques :
            </para>

            <programlisting role="php"><![CDATA[ <?php
$doc = new Zend_Search_Lucene_Document();

// Le champs n'est pas segmenté, mais est indexé et stocké dans l'index.
// Les champs stockés peuvent être récupérés à partir de l'index.
$doc->addField(Zend_Search_Lucene_Field::Keyword('doctype',
                                                 'autogenerated'));

// Le champs n'est ni segmenté ni indexé, mais est stocké dans l'index.
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created',
                                                   time()));

// Le champs contenant des données binaires n'est ni segmenté ni indexé, mais est stocké dans l'index
$doc->addField(Zend_Search_Lucene_Field::Binary('icon',
                                                $iconData));

// Le champs est segmenté et indexé et est stocké avec l'index. 
$doc->addField(Zend_Search_Lucene_Field::Text('annotation',
                                              'Document annotation text'));

// Le champs est segmenté et indexé, mais n'est pas stocké dans l'index.
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents',
                                                  'My document content'));

?>]]></programlisting>

            <para>
                Chacune de ces méthodes (sauf la méthode<code>Zend_Search_Lucene_Field::Binary()</code>) a un paramètre facultatif <code>$encoding</code> qui spécifie l'encodage de la donnée d'entrée.
            </para>

            <para>
                L'encodage peut pour des documents différents aussi bien que pour des champs différents dans un même document.

                <programlisting role="php"><![CDATA[<?php
$doc = new Zend_Search_Lucene_Document();
$doc->addField(Zend_Search_Lucene_Field::Text('title', $title, 'iso-8859-1'));
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', $contents, 'utf-8'));
?>]]></programlisting>
            </para>

            <para>
                Si le paramètre d'encodage est omis, alors l'option régionale est utilisé au moment de l'éxécution. Par exemple :
                <programlisting role="php"><![CDATA[<?php
setlocale(LC_ALL, 'de_DE.iso-8859-1');
...
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', $contents));
?>]]></programlisting>
            </para>

            <para>
                Les champs sont toujours stockés et retournés de l'index en encodage UTF-8. La conversion vers l'UTF-8 est réalisée automatiquement.
            </para>

            <para>
                Les analyseurs textuels (<link linkend="zend.search.lucene.extending.analysis">voir ci-dessous</link>) peuvent aussi convertir les textes vers d'autres encodages. En réalité, l'analyseur par défaut convertit les textes vers l'encodage "ASCII//TRANSLIT". Faîtes attention à ceci, ces traductions peuvent dépendre l'option régionale courante.
            </para>

            <para>
                Vous pouvez donner le nom que vous voulez aux champs.
            </para>

            <para>
                Java Lucene utilise le champs "contents" comme le champ de recherche par défaut. Zend_Search_Lucene recherche dans tous les champs par défaut, mais il est possible de changer ce comportement.
                Voir le chapitre <link linkend="zend.search.lucene.query-language.fields">"Champ de recherche par défaut"</link> pour les détails.
            </para>

    </sect2>

    <sect2 id="zend.search.lucene.index-creation.understanding-field-types">
        <title>Comprendre les types de champs</title>
        <itemizedlist>
            <listitem>
                <para>
                    Les champs <code>Keyword</code> sont stockés et indexés, c'est à dire qu'il est possible de rechercher
                    dedans, aussi bien que les afficher dans les résultats de recherche.
                    Ils ne sont pas séparés en mots par le processus de tokenization.
                    Les champs énumérés d'une base de données se traduisent bien en champs <code>Keyword</code>
                    pour Zend_Search_Lucene.
                </para>
            </listitem>
            <listitem>
                <para>
                    Les champs <code>UnIndexed</code> n'offrent pas de possibilité de recherche, mais sont retournés
                    avec les résultats de recherche.
                    Les timestamps et clés primaires de base de données, chemins du système de fichiers, et tout autre
                    identifiant externe sont de bons candidats pour des champs <code>UnIndexed</code>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Les champs <code>Binary</code> ne sont ni tokenizés, ni indexés, mais sont stockés pour être récupérés
                    avec les résultats de recherche.
                    Ils peuvent être utilisés pour stocker toute donnée encodée comme chaine binaire, comme par exemple
                    des icônes.
                </para>
            </listitem>
            <listitem>
                <para>
                    Les champs <code>Text</code> sont stockés, indexés et tokenizés. Les champs <code>Text</code> sont
                    bien appropriés pour stocker des informations comme des sujets et titres qui doivent être recherchables
                    aussi bien que retournés avec les résultats de recherche.
                </para>
            </listitem>
            <listitem>
                <para>
                    Les champs <code>UnStored</code> sont tokenizés et indexés, mais pas stockés dans l'index.
                    Les grandes quantités de texte sont mieux indexées en utilisant ce type de champ. Stocker
                    de données crée un index plus grand sur le disque, donc si vous avez besoin d'effectuer une
                    recherche, mais de ne pas ré-afficher les données, utiliser le champ <code>UnStored</code>.
                    Les champs <code>UnStored</code> sont pratiques lorsque l'on souhaite utiliser un index Zend_Search_Lucene
                    en combinaison avec une base de données relationnelle. Vous pouvez indexer de gros champs de fichiers dédiés
                    à la recherche avec les champs <code>UnStored</code>, et les récupérer depuis votre base de données en utilisant
                    un champ séparé comme identifiant.
               </para>

                <table>
                    <title>Types de Zend_Search_Lucene_Field</title>
                    <tgroup cols="4">
                        <thead>
                            <row>
                                <entry>Type de champ</entry>
                                <entry>Stocké</entry>
                                <entry>Indexé</entry>
                                <entry>Tokenizé</entry>
                                <entry>Binaire</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Keyword</entry>
                                <entry>Oui</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                                <entry>Non</entry>
                            </row>
                            <row>
                                <entry>UnIndexed</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                                <entry>Non</entry>
                                <entry>Non</entry>
                            </row>
                            <row>
                                <entry>Binary</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                                <entry>Non</entry>
                                <entry>Oui</entry>
                            </row>
                            <row>
                                <entry>Text</entry>
                                <entry>Oui</entry>
                                <entry>Oui</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                            </row>
                            <row>
                                <entry>UnStored</entry>
                                <entry>Non</entry>
                                <entry>Oui</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
           </listitem>
       </itemizedlist>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.html-documents">
        <title>Documents HTML</title>
        <para>
            Zend_Search_Lucene offre une fonctionnalité de parseur HTML. Les documents peuvent être créés directement à partir de fichiers HTML ou à partir de chaînes de caractères :
            <programlisting role="php"><![CDATA[<?php
$doc = Zend_Search_Lucene_Document_Html::loadHTMLFile($filename);
$index->addDocument($doc);
...
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$index->addDocument($doc);
?>]]></programlisting>
        </para>

        <para>
            La classe <code>Zend_Search_Lucene_Document_Html</code> utilise les méthodes <code>DOMDocument::loadHTML()</code> et
            <code>DOMDocument::loadHTMLFile()</code> pour parser la source HTML, ainsi il n'est pas nécessaire que le HTML soit bien formé ou soit du XHTML. D'un autre côté elle est sensible à l'encodage mentionné dans la balise d'entête "meta http-equiv".
        </para>

        <para>
            La classe <code>Zend_Search_Lucene_Document_Html</code> reconnaît le titre du document, le contenu ("body") et les métabalises de l'entête du document.
        </para>

        <para>
            Le champs "title" est en réalité la valeur "/html/head/title". Il est stocké dans l'index, segmenté et disponible pour les recherches.
        </para>

        <para>
            Le champs "body" est le contenu de la balise body. Il ne contient pas les scripts, les commentaires et les attributs de balises.
        </para>

        <para>
            Les méthodes <code>loadHTML()</code> et <code>loadHTMLFile()</code> de la classe <code>Zend_Search_Lucene_Document_Html</code> ont aussi un second argument falcultatif.Si il est activé à <code>true</code>, alors le contenu de body est stocké dans l'index et peut être récupéré. Le contenu body est seulement segmenté et indexé, mais pas stocké par défaut.
        </para>

        <para>
            Les métabalises d'entête du document produisent des champs additionnels. Le nom du champs est pris à partir de l'attribut "name", l'attribut "content" donne la valeur du champs, qui est segmenté, indéxé et stocké, ainsi les documents peuvent être recherché par leurs métabalises (par exemple, par les mots-clés)
        </para>

        <para>
            Les documents parsés peuvent être étendus par les utilisateurs avec tout autre champs :
            <programlisting role="php"><![CDATA[<?php
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created',
                                                   time()));
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created',
                                                   time()));
$doc->addField(Zend_Search_Lucene_Field::Text('annotation',
                                              'Document annotation text'));
$index->addDocument($doc);
?>]]></programlisting>
        </para>

        <para>
            Les hyperliens du document ne sont pas inclus dans le document généré, mais peuvent être récupérés avec les méthodes <code>Zend_Search_Lucene_Document_Html::getLinks()</code> et <code>Zend_Search_Lucene_Document_Html::getHeaderLinks()</code> :
            <programlisting role="php"><![CDATA[<?php
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$linksArray = $doc->getLinks();
$headerLinksArray = $doc->getHeaderLinks();
?>]]></programlisting>
        </para>
    </sect2>
</sect1>