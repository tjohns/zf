<sect1 id="zend.openid.consumer">
    <title>Zend_OpenId_Consumer Grundlagen</title>
    <para>
        <code>Zend_OpenId_Consumer</code> wird verwendet um das OpenID Authentifizierungs Schema auf Webseiten
        zu implementieren.
    </para>

    <sect2 id="zend.openid.consumer.authentication">
        <title>OpenID Authentifikation</title>
        <para>
            Aus der Sicht eines Site Entwicklers, geschieht die Authentifikation von OpenID in drei Schritten:
        </para>

        <orderedlist>
            <listitem>
                Zeige das OpenID Authentifikations Formular.
            </listitem>

            <listitem>
                Akzeptiere die OpenID Identität und übergib Sie an den OpenID Provider.
            </listitem>

            <listitem>
                Überprüfe die Antwort des OpenID Providers.
            </listitem>
        </orderedlist>

        <para>
            In Wirklichkeit führt das OpenID Authentifikations Protokoll mehr Schritte durch, aber die meisten
            von Ihnen sind innerhalb von <code>Zend_OpenId_Consumer</code> gekapselt, und sind für den
            Entwickler transparent.
        </para>

        <para>
            Der OpenID Authentifikations Prozess wird vom End-Benutzer, durch das Ausfüllen seiner Identifikation
            im entsprechenden Formular und dem Senden des selben, durchgeführt. Das folgende Beispiel zeigt ein
            einfaches Formular das einen OpenID Identifikator akzeptiert. Es gilt zu beachten das das Beispiel
            nur einen Login zeigt.
        </para>

        <example id="zend.openid.consumer.example-1">
            <title>Das einfache OpenID Login Formular</title>
            <programlisting role="php"><![CDATA[<html><body>
<form method="post" action="example-1_2.php"><fieldset>
<legend>OpenID Login</legend>
<input type="text" name="openid_identifier">
<input type="submit" name="openid_action" value="login">
</fieldset></form></body></html>]]>
            </programlisting>
        </example>

        <para>
            Beim Übertragen übergibt dieses Formular eine OpenID Identität an das folgende PHP Skript welches
            den zweiten Schritt der Authentifizierung durchführt. Das einzige Ding für das dieses PHP Skript
            benötigt wird ist in diesem Schritt die <code>Zend_OpenId_Consumer::login()</code> Methode auszurufen.
            Das erste Argument dieser Methode akzeptiert eine OpenID Identität und das zweite ist eine URL des
            Skripts das den dritten und letzten Schritt der Authentifizierung behandelt.
        </para>

        <example id="zend.openid.consumer.example-1_2">
            <title>Der Authentifizierungs Anfrage Handler</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$consumer = new Zend_OpenId_Consumer();
if (!$consumer->login($_POST['openid_identifier'], 'example-1_3.php')) {
    die("OpenID Login fehlgeschlagen.");
}]]>
            </programlisting>
        </example>

        <para>
            <code>Zend_OpenId_Consumer::login()</code> führt eine Suche nach einem gegebenen Identifizierer
            durch und findet, bei Erfolg, die Adresse des Identitäts Providers und dessen Lokalen Idenzifizierer
            durch. Dann erstellt es eine Assoziation zum gegebenen Provider sodas beide, die Site und der
            Provider, um das gleiche Geheimnis wissen das verwendet wurde um die nachfolgende Nachricht zu
            verschlüsseln. Das wird eine Authentifikations Anfrage an den Provider übergeben. Es ist zu
            beachten das der Web-Browser des End-Benutzers zu einer OpenID Server Site umleitet, wo die
            Benutzer die Möglcihkeit haben den Authentifizierungs Prozess fortzuführen. 
        </para>

        <para>
            Ein OpenID Server fragt nochmalerweise Benutzer nach Ihrem Passwort (wenn Sie vorher noch nicht
            angemeldet waren), wenn der Benutzer dieser Site vertraut und welche Informationen zu der Site
            zurückgegeben werden können. Diese Interaktionen sind für die OpenID-aktivierte Site nicht sichtbar
            sodas es für diese keine Möglichkeit gibt ein Benutzerpasswort oder andere Informationen zu
            bekommen die nicht geöffnet wurden.
        </para>

        <para>
            Bei Erfolg wird <code>Zend_OpenId_Consumer::login()</code> nie zurückkommen, weil es eine HTTP
            Umleitung durchführt, aber im Falle eine Fehler ein false zurückgeben wird. Fehler können durch
            eine ungültige Identität, einen toten Provider, Kommunikations Fehler, usw. auftreten.
        </para>

        <para>
            Der dritte Schritt der Authentifikation wird durch eine Antwort vom OpenID Provider initiiert,
            nachdem dieser das Benutzerpasswort authentifiziert hat. Diese Antwort wird indirekt, als HTTP
            Umleitung des Webbrowsers des End-Benutzers, übergeben. Und das einzige, was die Site tun muß,
            ist zu prüfen ob Antwort gültig ist.
        </para>

        <example id="zend.openid.consumer.example-1_3">
            <title>Der Authentifizierungs Antwort Prüfer</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$consumer = new Zend_OpenId_Consumer();
if ($consumer->verify($_GET, $id)) {
    echo "GÜLTIG $id";
} else {
    echo "UNGÜLTIG $id";
}]]>
            </programlisting>
        </example>

        <para>
            Diese Prüfung wird durchgeführt indem die <code>Zend_OpenId_Consumer::verify</code> Methode
            verwendet wird, welche ein ganzes Array von HTTP Anfrage Argumenten entgegennimmt und prüft ob
            diese Antwort durch einen entsprechenden OpenID Provider richtig signiert wurde. Sie kann auch
            die erhaltete OpenID Identität, die vom End-Benutzer im ersten Schritt in das zweite (optionale)
            Argument eingegeben wurde, zuordnen. 
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.combine">
        <title>Alle Schritte in einer Seite kombinieren</title>
        <para>
            The following example combines all three steps together. It doesn't
            provide any additional functionality. The only advantage is that now
            developers don't need to specify any URL's of scripts that handle the next
            step. By default, all steps use the same URL. However, the script now
            includes a dispatch code that calls appropriate code for each step of
            authentication.
        </para>

        <example id="zend.openid.consumer.example-2">
            <title>The Complete OpenID Login Script</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$status = "";
if (isset($_POST['openid_action']) &&
    $_POST['openid_action'] == "login" &&
    !empty($_POST['openid_identifier'])) {

    $consumer = new Zend_OpenId_Consumer();
    if (!$consumer->login($_POST['openid_identifier'])) {
        $status = "OpenID login failed.<br>";
    }
} else if (isset($_GET['openid_mode'])) {
    if ($_GET['openid_mode'] == "id_res") {
        $consumer = new Zend_OpenId_Consumer();
        if ($consumer->verify($_GET, $id)) {
            $status = "VALID $id";
        } else {
            $status = "INVALID $id";
        }
    } else if ($_GET['openid_mode'] == "cancel") {
        $status = "CANCELED";
    }
}
?>
<html><body>
<?php echo "$status<br>";?>
<form method="post"><fieldset>
<legend>OpenID Login</legend>
<input type="text" name="openid_identifier" value="">
<input type="submit" name="openid_action" value="login">
</fieldset></form></body></html>]]>
            </programlisting>
        </example>

        <para>
            In addition, this code differenciates between canceled and wrong
            authentication responses. The provider retuns a canceled responce in cases
            when an identity provider doesn't know the supplied identity or the user
            is not logged-in or they don't trust the site. A wrong response assumes
            that the responce is wrong or incorrectly signed.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.realm">
        <title>Realm</title>
        <para>
            When an OpenID-enabled site passes authentication requests to a
            provider, it identifies itself with a realm URL. This URL may be
            considered as a root of a trusted site. If the user trusts the URL they
            will also trust to matched and subsequent URLs.
        </para>

        <para>
            By default, the realm URL is automatically set to the URL of the
            directory where the login script is. This decision is useful for most, but
            not all cases. Sometimes a whole site and not directory is used, or even a
            combination of several servers from one domain.
        </para>

        <para>
            To implement this ability, developers may pass the realm value as a
            third argument to the <code>Zend_OpenId_Consumer::login</code> method. In
            the following example the single interaction asks for trusted access to
            all php.net sites.
        </para>

        <example id="zend.openid.consumer.example-3_2">
            <title>Authentication Request for Specified Realm</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$consumer = new Zend_OpenId_Consumer();
if (!$consumer->login($_POST['openid_identifier'], 'example-3_3.php', 'http://*.php.net/')) {
    die("OpenID login failed.");
}]]>
            </programlisting>
        </example>

        <para>
            The example below only implements the second step of authentication,
            the first and third steps are the same as in the first example.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.check">
        <title>Immediate Check</title>
        <para>
            In some situations it is necissary to see if a user is already
            logged-in into a trusted OpenID server without any interaction with the
            user. The <code>Zend_OpenId_Consumer::check</code> method does precisely
            that. It is executed with exactly the same arguments as
            <code>Zend_OpenId_Consumer::login</code> but it doesn't show the user any
            OpenID server pages. Therefore from the users point of view it is
            transparent and it seems as if they never left the site. The third step
            succeedes if user is already logged-in and trusted to the site otherwise
            it will fail.
        </para>

        <example id="zend.openid.consumer.example-4">
            <title>Immediate Check without Interaction</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$consumer = new Zend_OpenId_Consumer();
if (!$consumer->check($_POST['openid_identifier'], 'example-4_3.php')) {
    die("OpenID login failed.");
}]]>
            </programlisting>
        </example>

        <para>
            The example below only implements the second step of authentication,
            first and third steps are the same as in the first example.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.storage">
        <title>Zend_OpenId_Consumer_Storage</title>
        <para>
            There are three steps to the OpenID authentication procedure, each
            step is performed by a separate HTTP request. To store information between
            requests <code>Zend_OpenId_Consumer</code> uses internal storage.
        </para>

        <para>
            Developers may not care about this storage because by default
            <code>Zend_OpenId_Consumer</code> uses file-based storage under /tmp
            similar to PHP sessions. However, this storage may be not suitable in all
            cases. Some may want to store information in a database while others may
            need to use common storage suitable for big web-farms. Fortunately,
            developers may easily replace the default storage with their own. The only
            thing to implement is it's own storage class as a child of
            the <code>Zend_OpenId_Consumer_Storage</code> method and pass it as a first
            argument to the <code>Zend_OpenId_Consumer</code> constructor.
        </para>

        <para>
            The following example demonstrates a simple storage that uses
            <code>Zend_Db</code> as the backend containing three groups of functions.
            the first is for working with associations, the second is to cache
            discovery information and the third is to check responce uniqueness. The
            class is implemented in such a way that it can be easily used with
            existing or new databases. If necessary, it will create database tables if
            they don't exist.
        </para>

        <example id="zend.openid.consumer.example-5">
            <title>Databse Storage</title>
            <programlisting role="php"><![CDATA[<?php
class DbStorage extends Zend_OpenId_Consumer_Storage
{
    private $_db;
    private $_association_table;
    private $_discovery_table;
    private $_nonce_table;

    public function __construct($db,
                                $association_table = "association",
                                $discovery_table = "discovery",
                                $nonce_table = "nonce")
    {
        $this->_db = $db;
        $this->_association_table = $association_table;
        $this->_discovery_table = $discovery_table;
        $this->_nonce_table = $nonce_table;
        $tables = $this->_db->listTables();
        if (!in_array($association_table, $tables)) {
            $this->_db->getConnection()->exec(
                "create table $association_table (" .
                " url     varchar(256) not null primary key," .
                " handle  varchar(256) not null," .
                " macFunc char(16) not null," .
                " secret  varchar(256) not null," .
                " expires timestamp" .
                ")");
        }
        if (!in_array($discovery_table, $tables)) {
            $this->_db->getConnection()->exec(
                "create table $discovery_table (" .
                " id      varchar(256) not null primary key," .
                " realId  varchar(256) not null," .
                " server  varchar(256) not null," .
                " version float," .
                " expires timestamp" .
                ")");
        }
        if (!in_array($nonce_table, $tables)) {
            $this->_db->getConnection()->exec(
                "create table $nonce_table (" .
                " nonce   varchar(256) not null primary key," .
                " created timestamp default current_timestamp" .
                ")");
        }
    }

    public function addAssociation($url, $handle, $macFunc, $secret, $expires)
    {
        $table = $this->_association_table;
        $secret = base64_encode($secret);
        $this->_db->query("insert into $table (url, handle, macFunc, secret, expires) " .
                          "values ('$url', '$handle', '$macFunc', '$secret', $expires)");
        return true;
    }

    public function getAssociation($url, &$handle, &$macFunc, &$secret, &$expires)
    {
        $table = $this->_association_table;
        $this->_db->query("delete from $table where expires < " . time());
        $res = $this->_db->fetchRow("select handle, macFunc, secret, expires from $table where url = '$url'");
        if (is_array($res)) {
            $handle  = $res['handle'];
            $macFunc = $res['macFunc'];
            $secret  = base64_decode($res['secret']);
            $expires = $res['expires'];
            return true;
        }
        return false;
    }

    public function getAssociationByHandle($handle, &$url, &$macFunc, &$secret, &$expires)
    {
        $table = $this->_association_table;
        $this->_db->query("delete from $table where expires < " . time());
        $res = $this->_db->fetchRow("select url, macFunc, secret, expires from $table where handle = '$handle'");
        if (is_array($res)) {
            $url     = $res['url'];
            $macFunc = $res['macFunc'];
            $secret  = base64_decode($res['secret']);
            $expires = $res['expires'];
            return true;
        }
        return false;
    }

    public function delAssociation($url)
    {
        $table = $this->_association_table;
        $this->_db->query("delete from $table where url = '$url'");
        return true;
    }

    public function addDiscoveryInfo($id, $realId, $server, $version, $expires)
    {
        $table = $this->_discovery_table;
        $this->_db->query("insert into $table (id, realId, server, version, expires) " .
                          "values ('$id', '$realId', '$server', $version, $expires)");
        return true;
    }

    public function getDiscoveryInfo($id, &$realId, &$server, &$version, &$expires)
    {
        $table = $this->_discovery_table;
        $this->_db->query("delete from $table where expires < " . time());
        $res = $this->_db->fetchRow("select realId, server, version, expires from $table where id = '$id'");
        if (is_array($res)) {
            $realId  = $res['realId'];
            $server  = $res['server'];
            $version = $res['version'];
            $expires = $res['expires'];
            return true;
        }
        return false;
    }

    public function delDiscoveryInfo($id)
    {
        $table = $this->_discovery_table;
        $this->_db->query("delete from $table where id = '$id'");
        return true;
    }

    public function isUniqueNonce($nonce)
    {
        $table = $this->_nonce_table;
        try {
            $ret = $this->_db->query("insert into $table (nonce) values ('$nonce')");
        } catch (Zend_Db_Statement_Exception $e) {
            return false;
        }
        return true;
    }

    public function purgeNonces($date=null)
    {
    }
}

$db = Zend_Db::factory('Pdo_Sqlite',
    array('dbname'=>'/tmp/openid_consumer.db'));
$storage = new DbStorage($db);
$consumer = new Zend_OpenId_Consumer($storage);]]>
            </programlisting>
        </example>

        <para>
            The example doesn't include OpenID authentication code itself, but
            it is based on the same logic as in the previous or following
            examples.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.sreg">
        <title>Simple Registration Extension</title>
        <para>
            In addition to authentication, the OpenID can be used for
            light-weight profile exchange. This feature is not covered by OpenID
            authentication specification but by the OpenID Simple Registration
            Extension protocol. This protocol allows OpenID-enabled sites to ask for
            information about an end-user from OpenID providers. Such information may
            include:
        </para>

        <itemizedlist>
            <listitem>
                <emphasis>nickname</emphasis>
                 - any UTF-8 string that the end user wants to use as a nickname.
            </listitem>
            <listitem>
                <emphasis>email</emphasis>
                - the email address of the end user as specified in section 3.4.1
                of RFC2822.
            </listitem>
            <listitem>
                <emphasis>fullname</emphasis>
                - a UTF-8 string representation of the end user's full name.
            </listitem>
            <listitem>
                <emphasis>dob</emphasis>
                - the end user's date of birth as YYYY-MM-DD. Any values whose
                representation uses fewer than the specified number of digits
                should be zero-padded. The length of this value must always be
                10. If the end user does not want to reveal any particular
                component of this value, it must be set to zero. For instance,
                if a end user wants to specify that his date of birth is in 1980,
                but not the month or day, the value returned shall be "1980-00-00".
            </listitem>
            <listitem>
                <emphasis>gender</emphasis>
                - the end user's gender, "M" for male, "F" for female.
            </listitem>
            <listitem>
                <emphasis>postcode</emphasis>
                - UTF-8 string that should conform to the end user's country's
                postal system.
            </listitem>
            <listitem>
                <emphasis>country</emphasis>
                - the End User's country of residence as specified by ISO3166.
            </listitem>
            <listitem>
                <emphasis>language</emphasis>
                - end User's preferred language as specified by ISO639.
            </listitem>
            <listitem>
                <emphasis>timezone</emphasis>
                - ASCII string from TimeZone database. For example,
                "Europe/Paris" or "America/Los_Angeles".
            </listitem>
        </itemizedlist>

        <para>
            An OpenID-enabled web site may ask for any combination of these
            fields. It may also strictly require some information and allow end-users
            to provide or hide other information. The following example creates an
            object of the <code>Zend_OpenId_Extension_Sreg</code> class that requires
            a <emphasis>nickname</emphasis> and optionally ask for
            <emphasis>email</emphasis> and <emphasis>fullname</emphasis>.
        </para>

        <example id="zend.openid.consumer.example-6_2">
            <title>Sending Requests with a Simple Registration Extension</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";
require_once "Zend/OpenId/Extension/Sreg.php";

$sreg = new Zend_OpenId_Extension_Sreg(array(
    'nickname'=>true,
    'email'=>false,
    'fullname'=>false), null, 1.1);
$consumer = new Zend_OpenId_Consumer();
if (!$consumer->login($_POST['openid_identifier'], 'example-6_3.php', null, $sreg)) {
    die("OpenID login failed.");
}]]>
            </programlisting>
        </example>

        <para>
            As you can see the <code>Zend_OpenId_Extension_Sreg</code>
            constructor accepts an array of asked fields. This array has the names of
            fields as indexes and requirements flag as values.
            <emphasis>true</emphasis> means the field is required and
            <emphasis>false</emphasis> means the field is optional. The
            <code>Zend_OpenId_Consumer::login</code> accepts extensions or list of
            extensions as a fourth argument.
        </para>

        <para>
            On the third step of authentication, the
            <code>Zend_OpenId_Extension_Sreg</code> object should be passed to
            <code>Zend_OpenId_Consumer::verify</code>. Then on successful authentication
            <code>Zend_OpenId_Extension_Sreg::getProperties</code> will return an
            associative array of requested fields.
        </para>

        <example id="zend.openid.consumer.example-6_3">
            <title>Verifying Responses with a Simple Registration Extension</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";
require_once "Zend/OpenId/Extension/Sreg.php";

$sreg = new Zend_OpenId_Extension_Sreg(array(
    'nickname'=>true,
    'email'=>false,
    'fullname'=>false), null, 1.1);
$consumer = new Zend_OpenId_Consumer();
if ($consumer->verify($_GET, $id, $sreg)) {
    echo "VALID $id<br>\n";
    $data = $sreg->getProperties();
    if (isset($data['nickname'])) {
        echo "nickname: " . $data['nickname'] . "<br>\n";
    }
    if (isset($data['email'])) {
        echo "email: " . $data['email'] . "<br>\n";
    }
    if (isset($data['fullname'])) {
        echo "fullname: " . $data['fullname'] . "<br>\n";
    }
} else {
    echo "INVALID $id";
}]]>
            </programlisting>
        </example>

        <para>
            If <code>Zend_OpenId_Extension_Sreg</code> was created without any
            arguments, the user code should check for the existence of the required
            data itself. However, if the object is created with the same list of
            required fields as on the second step, it will automatically check for the
            existence of required data. In this case, <code>Zend_OpenId_Consumer::verify</code>
             will return <emphasis>false</emphasis> if any of the required fields are
            missing.
        </para>

        <para>
            By default, <code>Zend_OpenId_Extension_Sreg</code> uses version
            1.0, because the specification for version 1.1 is not yet finalized.
            However, some libraries don't fully support version 1.0. For example,
            www.myopenid.com requires an SREG namespace in requests which is only
            available in 1.1. To work with this server, explicitly set the version to
            1.1 in the <code>Zend_OpenId_Extension_Sreg</code> constructor.
        </para>

        <para>
            The second argument of the <code>Zend_OpenId_Extension_Sreg</code>
            constructor is a policy URL, that should be provided to the end-user by
            the identity provider.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.auth">
        <title>Integration with Zend_Auth</title>
        <para>
            Zend Framework provides a special class to support user
            authentication - <code>Zend_Auth</code>. This class can be used together
            with <code>Zend_OpenId_Consumer</code>. The following example shows how
            <code>OpenIdAdapter</code> implements
            the <code>Zend_Auth_Adapter_Interface</code> with the
            <code>authenticate</code> method.This performs an authentication query and
            verification.
        </para>

        <para>
            The big difference between this adapter and existing ones, is that
            it works on two HTTP requests and includes a dispatch code to perform the
            second or third step of OpenID authentication.
        </para>

        <example id="zend.openid.consumer.example-7">
            <title>Zend_Auth Adapter for OpenID</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";
require_once "Zend/Auth.php";
require_once "Zend/Auth/Adapter/Interface.php";

class OpenIdAdapter implements Zend_Auth_Adapter_Interface {
    private $_id = null;

    public function __construct($id = null) {
        $this->_id = $id;
    }

    public function authenticate() {
        $id = $this->_id;
        if (!empty($id)) {
            $consumer = new Zend_OpenId_Consumer();
            if (!$consumer->login($id)) {
                $ret = false;
                $mdg = "Authentication failed.";
            }
        } else {
            $consumer = new Zend_OpenId_Consumer();
            if ($consumer->verify($_GET, $id)) {
                $ret = true;
                $msg = "Authentication successful";
            } else {
                $ret = false;
                $msg = "Authentication failed";
            }
        }
        return new Zend_Auth_Result($ret, $id, array($msg));
    }
}

$status = "";
$auth = Zend_Auth::getInstance();
if ((isset($_POST['openid_action']) &&
     $_POST['openid_action'] == "login" &&
     !empty($_POST['openid_identifier'])) ||
    isset($_GET['openid_mode'])) {
    $adapter = new OpenIdAdapter(@$_POST['openid_identifier']);
    $result = $auth->authenticate($adapter);
    if ($result->isValid()) {
        Zend_OpenId::redirect(Zend_OpenId::selfURL());
    } else {
        $auth->clearIdentity();
        foreach ($result->getMessages() as $message) {
            $status .= "$message<br>\n";
        }
    }
} else if ($auth->hasIdentity()) {
    if (isset($_POST['openid_action']) &&
        $_POST['openid_action'] == "logout") {
        $auth->clearIdentity();
    } else {
        $status = "Yoy are logged-in as " . $auth->getIdentity() . "<br>\n";
    }
}
?>
<html><body>
<?php echo "$status";?>
<form method="post"><fieldset>
<legend>OpenID Login</legend>
<input type="text" name="openid_identifier" value="">
<input type="submit" name="openid_action" value="login">
<input type="submit" name="openid_action" value="logout">
</fieldset></form></body></html>]]>
            </programlisting>
        </example>

        <para>
            With <code>Zend_Auth</code> the end-user's identity is saved in the
            session's data. It may be checked with <code>Zend_Auth::hasIdentity</code>
            and <code>Zend_Auth::getIdentity</code>.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.mvc">
        <title>Integration with Zend_Controller</title>
        <para>
            Finally a couple of words about integration into
            Model-View-Controller applications. Such Zend Framework applications are
            implemented using the <code>Zend_Controller</code> class and they use
            objects of the <code>Zend_Controller_Response_Http</code> class to prepare
            HTTP responses and send them back to the end user's web-browser.
        </para>

        <para>
            <code>Zend_OpenId_Consumer</code> doesn't provide any GUI
            capabilities but it performs HTTP redirections on success of
            <code>Zend_OpenId_Consumer::login</code> and
            <code>Zend_OpenId_Consumer::check</code>. These redirections, may work
            incorrectly or not work at all if some data was already sent to the
            web-browser. To properly perform HTTP redirection in MVC code the real
            <code>Zend_Controller_Response_Http</code> should be sent to
            <code>Zend_OpenId_Consumer::login</code> or
            <code>Zend_OpenId_Consumer::check</code> as the last argument.
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
