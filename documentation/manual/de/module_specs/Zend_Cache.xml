<sect1 id="zend.cache.introduction">
    <title>Einführung</title>
    <para>
        <code>Zend_Cache</code> bietet einen generellen Weg für das Cachen von Daten.
    </para>
    <para>
      Cachen im Zend Framework wird mit Frontends durchgeführt, wobei Cache Datensätze über Backend Adapter
      (<code>File</code>, <code>Sqlite</code>, <code>Memcache</code>...), durch ein flexibles System von
      IDs und Tags, gespeichert werden. Durch deren Verwendung ist es einfach spezielle Typen von Datensätzen im 
      Nachhinein zu Löschen (zum Beispiel: "Löschen aller Cache Datensätze welche mit einem bestimmten
      Tag markiert sind").
    </para>
    <para>
        Der Kern des Moduls (<code>Zend_Cache_Core</code>) ist generell, flexibel und konfigurierbar.
        Nun gibt es, für spezielle Bedürfnisse, Cache Frontends welche <code>Zend_Cache_Core</code>
        erweitern: <code>Output</code>, <code>File</code>, <code>Function</code> und <code>Class</code>.
    </para>
    <example>
        <title>Ein Frontend mit <code>Zend_Cache::factory()</code> erzeugen</title>
        <para>
            <code>Zend_Cache::factory()</code> instanziiert korrekte Objekte und fügt Sie zusammen.
            In diesem ersten Beispiel wird das <code>Core</code> Frontend zusammen mit dem 
            <code>File</code> Backend verwendet.
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200, // Lebensdauer des Caches 2 Stunden 
   'automaticSerialization' => true
);

$backendOptions = array(
    'cacheDir' => './tmp/' // Verzeichnis in welches die Cache Dateien kommen
);

// Ein Zend_Cache_Core Objekt erzeugen
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

?>]]></programlisting>
       </para>
       <para>
            Jetzt, da wir ein Frontend haben, kann jeder Typ von Daten gecached werden (Serialisierung ist
            eingeschaltet). Zum Beispiel können Ergebnisse von sehr umfangreichen Datenbank Abfragen
            gecached werden. Nach dem Cachen ist es sogar gar nicht nicht mehr notwendig eine Verbindung
            zur Datenbank zu machen; Datensätze werden vom Cache genommen und Deserialisiert.
            <programlisting role="php"><![CDATA[<?php

// $cache initialisiert im vorhergehenden Beispiel

// Nachsehen ob der Cache bereits existiert:
if(!$result = $cache->get('myresult')) {

    // Cache miss; zur Datenbank verbinden
    
    $db = Zend_Db::factory( [...] );
    
    $result = $db->fetchAll('SELECT * FROM huge_table');
    
    $cache->save($result, 'myresult');
    
} else {

    // Cache hit! Schreie damit wir es wissen
    echo "Der ist vom Cache!\n\n";
    
}

print_r($result);

?>]]></programlisting>
       </para>
    </example>
    <example>
        <title>Cache Ausgabe mit dem <code>Zend_Cache</code> Frontend</title>
        <para>
            Abschnitte, in denen die Ausgabe gecached werden soll, werden 'markiert', durch hinzufügen
            von etwas bedingter Logik, wobei der Abschnitt innerhalb der <code>start()</code> und <code>end()</code> Methoden
            gekapselt wird (das ähnelt dem ersten Beispiel, und ist eine Kern Strategie für das Cachen).
        </para><para>
            Darin muß die Ausgabe der Daten wie immer geschehen - jede Ausgabe wird gecached wenn die Ausführung auf
            die <code>end()</code> Methode trifft. Bei der nächsten Ausführung wird der komplette Abschnitt
            übersprungen dafür werden die Daten vom Cache geholt (solange der Cache Datensatz gültig ist).
            <programlisting role="php"><![CDATA[<?php

$frontendOptions = array(
   'lifeTime' => 30,                  // Lebenszeit des Caches cache lifetime of half a minute
   'automaticSerialization' => false  // Dieser Wert ist auf alle Fälle Standard
);

$backendOptions = array('cacheDir' => './tmp/');

$cache = Zend_Cache::factory('Output', 'File', $frontendOptions, $backendOptions);

// Wir übergeben eine eindeutige Identifizierung an die start() Methode
if(!$cache->start('mypage')) {
    // Ausgabe wie gewöhnlich:
    
    echo 'Hallo Welt! ';
    echo 'Das ist gecached ('.time().') ';
    
    $cache->end(); // Die Ausgabe wird gespeichert und zum Browser gesendet
}

echo 'Das wird nie gecached ('.time().').';

?>]]>       </programlisting>
       </para>
       <para>
           Zu beachten ist das das Ergebnis von <code>time()</code> zweimal ausgegeben wird; das ist
           etwas dynamisches für Demonstrations Zwecke. Beim Versuch dieses Auszuführen und mehrfach zu 
           Refreshen, kann bemerkt werden, das sich die erste Nummer nie ändert, wärend die zweite sich 
           ändert wärend die Zeit verstreicht. Das ist weil die erste Nummer, die im gecacheten Abschnitt 
           ausgegeben wird, im Gegensatz zur anderen Ausgabe gecached wurde.
           Nach einer halben Mintuten (die Lebensdauer wurde auf 30 Sekunden gesetzt) sind die Nummern
           wieder identisch weil der Cache Eintrag abgelaufen ist -- er muß wieder gecached werden.
           Man sollte das im Browser oder in der Konsole testen.
       </para>
    </example>
    <note><para>
        Wenn Zend_Cache benutzt wird, muß auf die wichtigen Cache Identifizierungen geachten werden (welche an
        <code>save()</code> und <code>start()</code> übergeben werden). Diese müssen einzigartig sein, für jede
        Ressource die gecached werden soll. Andernfalls würden sich unverknüpfte Cache Datensätze gegenseitig
        entfernen oder, noch schlimmer, anstatt des anderen dargestellt werden.
    </para></note>
</sect1>


<sect1 id="zend.cache.theory">
    <title>Die Theorie des Cachens</title>
    <para>
        Es gibt 3 Schlüssel Konzepte in Zend_Cache. Eines ist die eindeutige Identifizierung (ein String) 
        die benutzt wird, um Cache Datensätze zu identifizieren. Das zweite ist die <code>'lifeTime'</code>
        Direktive, wie im Beispiel gezeigt; Sie definiert wie lange eine gecachte Ressource als 'frisch'
        betrachtet wird. Das dritte Konzept ist die bedingte Ausführung, so das Teile des Codes komplett 
        übersprungen werden können, was die Leistung steigert.
        Die Haupt-Frontend Funktion (eg. <code>Zend_Cache_Core::get()</code>) ist immer so gestaltet, das
        false zurückgegeben wird, wenn ein Cache fehlt. Aber nur wenn das für die Natur des Frontends Sinn macht.
        Das erlaubt es End-Benutzern die Teile des Codes, die gecached (oder übersprungen) werden sollen, in
        <code>if(){ ... }</code> Anweisungen zu umhüllen wobei die Bedingung die Zend_Cache Methode selbst ist.
        Am Ende der Blöcke muss das erstellte auf alle Fälle gespeichert werden
        (z.B. <code>Zend_Cache_Core::save()</code>).
    </para>
    <note><para>
        Das Design der bedingten Ausführung des erzeugten Codes ist in einigen Frontends nicht notwendig
        (<code>Function</code>, zum Beispiel) wenn die komplette Logik im verwendeten Frontend integriert ist.
    </para></note>
    <note><para>
        'Cache hit' ist ein Ausdruck für eine Bedingung wenn ein Cache Datensatz gefunden wurde, er gültig und
        'frisch' ist (in anderen Worten, er ist noch nicht abgelaufen). 'Cache miss' ist alles andere.
        Wenn ein 'Cache miss' passiert, müssen die Daten erzeugt werden (wie man es normalerweise tun würde) und
        anschließend cachen. Wenn ein 'Cache hit' geschieht muß, auf der anderen Seite, das Backend automatisch den 
        Datensatz vom Cache transparent holen.
    </para></note>
    <sect2 id="zend.cache.factory">
        <title>Die <code>Zend_Cache</code> Factory Methode</title>
        <para>
            Ein guter Weg um eine verwendbare Instanz eines <code>Zend_Cache</code> Frontends zu erstellen wird im
            folgenden Beispiel gegeben :
            <programlisting role="php"><![CDATA[<?php
        
# Wir "laden" die Zend_Cache Factory 
require 'Zend/Cache.php'; 

# Wir wählen ein Backend (zum Beispiel 'File' oder 'Sqlite'...)
$backendName = '[...]';

# Wir wählen ein Frontend (zum Beispiel 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# Wir definieren ein Array von Optionen für das gewählte Frontend
$frontendOptions = array([...]);

# Wir definieren ein Array von Optionen für das gewählte Backend
$backendOptions = array([...]);

# Wir erstellen eine gute Instanz
# (natürlich sind die letzten 2 Argumente optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

?>]]></programlisting> 
        </para> 
        <para>
            In den folgenden Beispielen wird angenommen das die <code>$cache</code> Variable ein
            gültiges, initiiertes Frontend, wie gezeigt, enthält, und das verstanden wird, wie 
            Parameter an das ausgewählte Backend übergeben werden.
        </para>
        <note><para>
            Immer <code>Zend_Cache::factory()</code> benutzen um eine Frontend Instanz zu bekommen.
            Das selbstständige Instantiieren von Frontends und Backends funktioniert nicht so wie
            erwartet.
        </para></note>
    </sect2>
    
    <sect2 id="zend.cache.tags">
        <title>Markierte Datensätze</title>
        <para>
            Markierungen sind ein Weg um Cache Datensätze zu kategorisieren. Wenn der Cache mit der <code>save()</code>
            Methode abgespeichert werden soll, kann ein Array mit Markierungen für diesen Datensatz angelegt werden.
            Dann besteht die Möglichkeit alle markierten Cache Datensätze mit einer bestimmten Markierung (oder
            Markierungen), zu Löschen :
        <programlisting role="php"><![CDATA[<?php
             
$cache->save($huge_data, 'myUniqueID', array('tagA', 'tagB', 'tagC'));
            
?>]]></programlisting></para>
    </sect2>
    <sect2 id="zend.cache.clean">
        <title>Löschen des Caches</title>
        <para>
            Um eine bestimmte Cache ID zu entfernen/annullieren kann die <code>remove()</code> Methode benutzt werden :
             <programlisting role="php"><![CDATA[<?php 
             
$cache->remove('idToRemove');
            
?>]]></programlisting>            
        </para>
        <para>
            Um mehrere Cache IDs mit einer Operation zu entfernen/annulieren kann die <code>clean()</code> Methode
            benutzt werden. Zum Beispiel um alle Cache Datensätze zu entfernen :
              <programlisting role="php"><![CDATA[<?php 

// Löschen aller Datensätze
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);

// Nur abgelaufene löschen
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
            
?>]]>       </programlisting>    
            Um Cache Einträge zu Löschen die zu den Tags 'tagA' und 'tagC' passen :
              <programlisting role="php"><![CDATA[<?php 
             
$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tagA', 'tagC'));
            
?>]]>       </programlisting>
        </para>
        <para>
            Mögliche Löschemodi sind: <code>CLEANING_MODE_ALL</code>, <code>CLEANING_MODE_OLD</code>,
            <code>CLEANING_MODE_MATCHING_TAG</code> und <code>CLEANING_MODE_NOT_MATCHING_TAG</code>. 
            Die Letzteren sind, wie deren Namen vermuten lassen, kombiniert mit einem Array von Markierungen
            für die Löschoperation.
        </para>
    </sect2>
</sect1>

<sect1 id="zend.cache.frontends">
    <title>Zend_Cache Frontends</title>
    
    <sect2 id="zend.cache.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.core.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Core</code> ist ein spezielles Frontend, weil es der Kern dieses Moduls ist.
                Es ist ein Generelles Cache Frontend und ist durch andere Klassen erweiterbar.
            </para>
            <note><para>
                Alle Frontends sind von <code>Zend_Cache_Core</code> abgeleitet so das deren Methoden und
                Optionen (wie folgt beschrieben) auch in anderen Frontends vorhanden sind, deswegen werden
                Sie dort nicht dokumentiert.
            </para></note>
        </sect3>
        <sect3 id="zend.cache.core.options">
            <title>Mögliche Optionen</title>
            <para>
                Diese Optionen werden der Factory Methode übergeben wie im nachfolgenden Beispiel demonstriert.
            </para>
            <table>
                <title>Mögliche Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Ein- / Ausschalten vom Caching (Kann sehr nützlich sein, für das 
                                  debuggen von gecachten Skripten)
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifeTime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                Cache Lebensdauer (in Sekunden), wenn auf <code>null</code> gesetzt ist
                                der Cache für immer gültig.
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Wenn auf true gesetzt, wird das Logging durch <code>Zend_Log</code> aktiviert
                                (aber das System wird langsamer)
                              </entry>
                          </row>
                          <row>
                              <entry><code>writeControl</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Ein- / Ausschalten der Schreibkontrolle (der Cace wird gelesen gleich nachdem
                                er geschrieben wurde, um fehlerhafte Einträge zu finden); das Einschalten der
                                Schreibkontrolle wird das Schreiben des Caches etwas verlangsamen aber nicht das
                                Lesen des Caches (es können defekte Cache Dateien entdeckt werden, aber es ist 
                                keine perfekte Kontrolle)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticSerialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Ein- / Ausschalten der automatischen Serialisierung, kann dafür benutzt werden um
                                Daten direkt zu speichern welche keine Strings sind (aber es ist langsamer)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticCleaningFactor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>0</code></entry>
                              <entry>
                                Ausschalten / Abgleichen des automatischen Löschprozesses (Garbage Collector):
                                0 heißt keine automatische Löschung des Caches, 1 heißt Systematische Cache
                                Löschung und x &gt; 1 heißt automatisches zufälliges Löschen 1 mal nach 
                                x Schreiboperationen.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.core.examples">
            <title>Beispiele</title>
            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben.
            </para>
            <para>
                Wenn nur Strings in den Cache gespeichert werden (weil mit der "automaticSerialization" Option
                wäre es möglich Booleans zu speichern), kann ein kompakterer Weg wie folgt gewählt werden:
                 <programlisting role="php"><![CDATA[<?php  
             
// Es wird angenommen das $cache existiert

$id = 'myBigLoop'; // Die Cache ID von dem "das gecached werden soll"

if (!($data = $cache->get($id))) {
    // Cache miss
    
    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 

// [...] Irgendwas mit $data machen (Ausgeben, verarbeiten, usw.)
             
?>]]>       </programlisting> 
            </para>  
            <para>
                Wenn mehrere Blöcke von Daten oder Daten Instanzen gecached werden sollen, ist die 
                Idee dahinter die gleiche:
                 <programlisting role="php"><![CDATA[<?php  
             
// Sicherstellen das Eindeutige Identifizierer verwendet werden:
$id1 = 'foo';
$id2 = 'bar';

// Block 1
if (!($data = $cache->get($id1))) {
    // Cache miss
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 
echo($data);

// Hier wird NIE gecached
echo('NIE GECACHED! ');

// Block 2
if (!($data = $cache->get($id2))) {
    // Cache miss
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }
    
    $cache->save($data);
    
} 
echo($data);

?>]]>       </programlisting>             
            </para>            
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontend.output.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Frontend_Output</code> ist ein Ausgabe-Empfangendes Frontend. Es verwendet den
                Ausgabe Puffer in PHP um alles zwischen der <code>start()</code> und der <code>end()</code> Methode
                zu fangen.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.output.options">
            <title>Mögliche Optionen</title>
            <para>
                Dieses Frontend hat keine bestimmten Optionen zusätzlich zu denen von
                <code>Zend_Cache_Core</code>.
            </para>
        </sect3>
        
        <sect3 id="zend.cache.frontend.output.examples">
            <title>Beispiele</title>
            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben. Hier ist es mit kleinen Änderungen:
                 <programlisting role="php"><![CDATA[<?php

// Wenn es ein Cache Miss ist, wird das puffern der Ausgabe ausgelöst
if(!$cache->start('mypage')):

// Alle wie gewohnt ausgeben
echo 'Hallo Welt! ';
echo 'Das wird gecached ('.time().') ';

$cache->end(); // Ausgabepufferung beenden
endif;

echo 'Hier wird nie gecached ('.time().').';

?>]]>       </programlisting>
            </para>
            <para>
                Die Verwendung dieser Form ist ziemlich einfach um Ausgabe caching in einem bereits bestehenden
                Projekt, mit nur wenig oder gar keinen Codeänderungen, zu erhalten.
            </para>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontend.function.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Frontend_Function</code> cached das Ergebnis von Funktionsaufrufen. Es hat
                eine einzelne Hauptmethode genannt <code>call()</code> welche den Funktionsnamen und Parameter
                für den Aufruf, in einem Array, entgegennimmt.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.function.options">
            <title>Mögliche Optionen</title>
            <table>
                <title>Mögliche Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Wenn true, wird der Funktionsaufruf standardmäßig gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Funktionsnamen die immer gecached werden sollen
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Funktionsnamen die nie gecached werden sollen
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.function.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung der <code>call()</code> Funktion ist die gleiche wie die von
                <code>call_user_func_array()</code> in PHP:
                 <programlisting role="php"><![CDATA[<?php

$cache->call('veryExpensiveFunc', $params);

# $params ist ein Array
# Zum Beispiel fürs Aufrufen (mit cachen) von veryExpensiveFunc(1, 'foo', 'bar'), wird
# $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar')) benutzt

?>]]>       </programlisting>
            </para>
            <para>
                <code>Zend_Cache_Frontend_Function</code> ist elegant genug um beides zu cachen, den
                Rückgabewert der Funktion und deren interne Ausgabe.
            </para>
            <note><para>
                Man kann jede eingebaute oder benutzerdefinierte Funktion übergeben, mit ausnahme von
                <code>array()</code>, <code>echo()</code>, <code>empty()</code>, <code>eval()</code>,
                <code>exit()</code>, <code>isset()</code>, <code>list()</code>, <code>print()</code>
                und <code>unset()</code>. 
            </para></note>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontend.class.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Frontend_Class</code> ist unterschiedlich zu <code>Zend_Cache_Frontend_Function</code>
                weil es das Cachen von Objekten und Statischen Methodenaufrufen erlaubt.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.class.options">
            <title>Mögliche Optionen</title>
            <table>
                <title>Mögliche Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cachedEntity</code> (Notwendig)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  Wenn auf einen Klassen Namen gesetzt, wird eine abstrakte Klasse gecached und
                                  es werden statische Aufrufe verwendet; Wenn auf ein Objekt gesetzt, wird deren
                                  Objektmethoden gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Wenn true, wird der Aufruf standardmäßig gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Methodennamen die immer gecached werden sollen
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Methodennamen die nie gecached werden sollen
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.class.examples">
            <title>Beispiele</title>
            <para>
                zum Beispiel, um einen Statischen Aufruf zu cachen :
                <programlisting role="php"><![CDATA[<?php

class test {
   
    # Statische Methode
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => 'test' // Der Name der Klasse
);
// [...]

# Der gecachte Aufruf
$res = $cache->foobar('1', '2');

?>]]>           </programlisting>
                Um klassische Methodenaufrufe zu cachen :
                <programlisting role="php"><![CDATA[<?php

class test {
   
    private $_string = 'Hallo !';
      
    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => new test() // Eine Instanz der Klasse
);
// [...]

# Der gecachte Aufruf
$res = $cache->foobar2('1', '2');

?>]]>           </programlisting>
            </para>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Frontend_File</code> ist ein Frontend angetrieben durch den
                Änderungszeitpunkt einer "Masterdatei". Es ist wirklich interessant für Beispiele
                in Konfigurations- oder Templateanwendungen.
            </para>
            <para>
                Zum Beispiel eine XML Konfigurationsdatei welche von einer Funktion geparsed wird,
                und die ein "Config Objekt" zurückgibt (wie durch <code>Zend_Config</code>). Mit
                <code>Zend_Cache_Frontend_File</code> kann das "Config Objekt" im Cache gespeichert
                werden (um zu Verhindern, das die XML Konfiguration jedes mal geparsed wird), aber mit
                einer strengen Abhängigkeit zur "Masterdatei". Wenn also die XML Konfigurationsdatei
                geändert wird, wird der Cache sofort ungültig.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Mögliche Optionen</title>
            <table>
                <title>Mögliche Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>masterFile (mandatory)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  Der komplette Pfad und Name der Master Datei                 
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>   
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung dieses Frontends ist die gleiche wie die von <code>Zend_Cache_Core</code>. 
                Es gibt kein eigenes Beispiel - was als einziges gemacht werden muß, ist das <code>masterFile</code>
                zu definieren, wenn die Factory verwendet wird.
            </para>
        </sect3>
    </sect2>
    
    <sect2 id="zend.cache.frontends.page">
    	<title>Zend_Cache_Frontend_Page</title>
    	<sect3 id="zend.cache.frontends.page.introduction">
        	<title>Einführung</title>
        	<para>
	            <code>Zend_Cache_Frontend_Page</code> ist wie <code>Zend_Cache_Frontend_Output</code>
	            aber entwickelt für eine komplette Seite. Es ist unmöglich <code>Zend_Cache_Frontend_Page</code>
	            nur für das cachen eines einzelnen Blockes zu verwenden.
	        </para>
	        <para>
	        	Andererseits wird die "Cache ID" automatisch berechnet mit <code>$_SERVER['REQUEST_URI']</code> und
	        	(abhängig von den Optionen) mit
	        	<code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code>, <code>$_COOKIE</code>, <code>$_FILES</code>.
                Trotzdem muß nur eine Methode aufgerufen werden (<code>start()</code>) weil der Aufruf von 
                <code>end()</code> immer voll automatisch ist wenn die Seite endet.
	        </para>
	        <para>
	        	Zur Zeit ist es nicht eingebaut, aber es ist ein HTTP abhängiges System geplant um Bandbreiten zu
	        	sparen (Das System wird ein HTTP 304 nicht geändert schicken wenn der Cache gefunden wurde und wenn
	        	der Browser bereits eine gültige Version hat).
	        </para>
	        <note><para>
                Zend_Cache_Frontend_Page ist wirklich "Alpha Version" und ist zukünftig für Verbesserungen vorgesehen.
	        </para></note>
    	</sect3>
    	<sect3 id="zend.cache.frontends.page.options">
	        <title>Mögliche Optionen (Für dieses Frontend in der Zend_Cache Factory)</title>
	        <table>
	            <title>Mögliche Optionen</title>
	            <tgroup cols="4">
	                 <thead>
	                      <row>
	                        <entry>Option</entry>
	                        <entry>Daten Typ</entry>
	                        <entry>Standardwert</entry>
	                        <entry>Beschreibung</entry>
	                    </row>
	                 </thead>
	                 <tbody>
	                 	   <row>
	                          <entry><code>httpConditional</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              Verwendung des httpConditional Systems (zur Zeit nicht implementiert)
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>cacheWith{Get,Post,Session,Files,Cookie}Variables</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                                Wenn true, ist der Cache eingeschaltet, selbst wenn einige Variablen im entsprechenden Superglobalen Array sind;
	                                Wenn false, ist der Cache ausgeschaltet, wenn einige Variablen im entsprechenden Superglobalen Array sind 
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>makeIdWith{Get,Post,Session,Files,Cookie}Variables</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>true</code></entry>
	                          <entry>
	                                Wenn true, wird der Inhalt des entsprechenden Superglobalen Arrays verwendet im die Cache ID zu erstellen
                                    Wenn false, wird die Cache ID nicht vom Inhalt des Superglobalen Arrays abhängig sein
	                          </entry>
	                     </row>
	                  </tbody>
	              </tgroup>
	          </table>
	    </sect3>   
    	<sect3 id="zend.cache.frontends.page.examples">
        	<title>Beispiele</title>
	        <para>
	            Die Verwendung von Zend_Cache_Frontend_Page ist wirklich trivial :
	            <programlisting role="php"><![CDATA[<?php
	           
// [...] // Benötigt, Konfiguration und Factory
	
$cache->start();
# Wenn der Cache gefunden wurde, wird das ergebnis zum Browser geschickt, und das Skript stoppt hier
	
// Rest der Seite ...
	
?>]]>       </programlisting>
	        </para>
    	</sect3>
	</sect2>
    
</sect1>

<sect1 id="zend.cache.backends">
    <title>Zend_Cache Backends</title>
    
    <sect2 id="zend.cache.backends.file">
        <title>Zend_Cache_Backend_File</title>
        <para>
            Dieses Backend speichert Cache Datensätze in Dateien (in einem gewählten Verzeichnis).
        </para>
        <para>
            Mögliche Optionen sind :
        </para>          
        <table>
            <title>Mögliche Optionen</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Daten Typ</entry>
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDir</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'/tmp/'</code></entry>
                          <entry>
                              Verzeichnis in dem die Cache Dateien gespeichert werden
                          </entry>
                      </row>
                      <row>
                          <entry><code>fileLocking</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Ein- / Ausschalten von fileLocking : Kann die Beschädigung des Caches
                            unter schlechten Bedingungen verhindern aber es hilft nicht bei
                            Multithreaded Webservern oder bei NFS Filesystemen...
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControl</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Ein- / Ausschalten von readControl : Eingeschaltet wird ein Kontrollschlüssel
                            im Cache File imkludiert und dieser Schlüssel wird, mit dem Schlüssel der
                            nach dem Lesen berechnet wird, verglichen.
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControlType</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'crc32'</code></entry>
                          <entry>
                            Typ der Schreibkontrolle (nur wenn readControl eingeschaltet ist).
                            Mögliche Werte sind :
                            'md5' (Bestes aber am Langsamsten), 'crc32' (Etwas weniger sicher, aber schneller, beste
                            Wahl), 'strlen' um nur die Länge zu testen (schnellstes).
                        </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryLevel</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0</code></entry>
                          <entry>
                             Level der gehashten Verzeichnis Struktur : 0 heißt "keine gehashte 
                             Verzeichnis Strutur, 1 heißt "ein Level von Verzeichnissen", 2 heißt
                             "zwei Levels"...
                             Diese Option kann den Cache nur dann schneller machen wenn viele Tausende
                             Cache Dateien verwendet werden. Nur spezielle Messungen können helfen den perfekten
                             Wert zu finden. Möglicherweise ist 1 oder 2 ein guter Anfang.
                          </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryUmask</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0700</code></entry>
                          <entry>
                              Umask für die gehashte Verzeichnis Struktur
                        </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
        <title>Zend_Cache_Backend_Sqlite</title>
        <para>
            Dieses Backend speichert die Cache Datensätze in einer SQLite Datenbank.
        </para>
        <para>
            Mögliche Optionen sind :
        </para>
        <table>
            <title>Mögliche Optionen</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                           <entry>Option</entry>
                        <entry>Daten Typ</entry>
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDBCompletePath (mandatory)</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>null</code></entry>
                          <entry>
                              Der komplette Pfad (inklusive Dateiname) der SQLite Datenbank
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.memcached">
        <title>Zend_Cache_Backend_Memcached</title>
        <para>
            Dieses Backend speichert Cache Datensätze in einem Memcache Server. <ulink url="http://www.danga.com/memcached/">memcached</ulink>
            ist ein hoch-performantes, verteiltes Speicher Objekt Caching System. Um dieses Backend zu benutzen,
            wird ein Memcached Dämon benötigt und <ulink url="http://pecl.php.net/package/memcache">die memcache PECL Erweiterung</ulink>.
        </para>
        <para>
        	Vorsicht : Mit diesem Backend werden zur Zeit "Marker" nicht unterstützt genauso wie das
        	"doNotTestCacheValidity=true" Argument.
        </para>
        <para>
            Mögliche Optionen sind :
        </para>
        <table>
            <title>Mögliche Optionen</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Daten Typ</entry>
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>servers</code></entry>
                          <entry><code>array</code></entry>
                          <entry><code>array(array('host' => 'localhost','port' => 11211, 'persistent' => true))</code></entry>
                          <entry>
                              Ein Array von Memcached Servern ; Jeder Memcached Server wird beschrieben durch ein
                              assoziatives Array :
                              'host' => (string) : Der Name des Memcached Servers, 
                              'port' => (int) : Der Port des Memcached Servers, 
                              'persistent' => (bool) : Persistente Verbindungen für diesen Memcached Server verwenden oder nicht
                          </entry>
                      </row>
                      <row>
                          <entry><code>compression</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>flase</code></entry>
                          <entry>
                             true wenn on-the-fly Kompression verwendet werden soll
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.apc">
        <title>Zend_Cache_Backend_APC</title>
        <para>
            Dieses Backend speichert Cache Datensätze im Shared Memory durch die 
            <ulink url="http://pecl.php.net/package/APC">APC</ulink> (Alternativer PHP Cache) Erweiterung
            (Welche natürlich für die Verwendung dieses Backends benötigt wird).
        </para>
        <para>
        	Vorsicht : Mit diesem Backend werden zur Zeit "Marker" nicht unterstützt genauso wie das
        	"doNotTestCacheValidity=true" Argument.
        </para>
        <para>
            Es gibt keine Optionen für dieses Backend.
        </para>
    </sect2>
</sect1> 
  
<!--
vim:se ts=4 sw=4 et:
-->