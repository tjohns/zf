<sect1 id="zend.db.table">

    <title>Zend_Db_Table</title>

    <sect2 id="zend.db.table.introduction">

        <title>Introduction to Table Class</title>

        <para>
            The Zend_Db_Table class is an object-oriented
            interface to database tables.  It provides method for
            many common operations on tables.  The base class is
            extensible, so you can add custom logic.
        </para>

        <para>
            The Zend_Db_Table solution is an implementation of
            the <ulink url="http://www.martinfowler.com/eaaCatalog/tableDataGateway.html">Table Data Gateway</ulink> pattern.
            The solution also includes a class that implements
            the <ulink url="http://www.martinfowler.com/eaaCatalog/rowDataGateway.html">Row Data Gateway</ulink> pattern.
        </para>

    </sect2>

    <sect2 id="zend.db.table.defining">
        <title>Defining a Table Class</title>

        <para>
            For each table in your database you want to access,
            define a class that extends Zend_Db_Table_Abstract.
        </para>

        <para>
            In this section, we use an example database that tracks
            bugs in a software development project.
            The following SQL data definition language pseudocode
            describes a table in this example database.
        </para>

        <programlisting><![CDATA[
CREATE TABLE bugs (
  bug_id          INT PRIMARY KEY AUTO_INCREMENT,
  created_on      DATETIME,
  updated_on      DATETIME
  bug_description VARCHAR,
  bug_status      VARCHAR REFERENCES bug_statuses(bug_status)
);

CREATE TABLE bug_status (
  bug_status      VARCHAR PRIMARY KEY
);

CREATE TABLE products (
  product_id      VARCHAR PRIMARY KEY
);

CREATE TABLE bugs_products (
  bug_id          INT REFERENCES bugs(bug_id),
  product_id      VARCHAR REFERENCES products(product_id),
  PRIMARY KEY(bug_id, product_id)
);
]]></programlisting>

        <sect3 id="zend.db.table.defining.table-schema">

            <title>Defining the Table Name and Schema</title>

            <para>
                Declare the database table for which this class is defined,
                using the protected variable <code>$_name</code>.
                This is a string, and must contain the name of the table
                spelled as it appears in the database.
            </para>

            <example id="zend.db.table.defining.table-schema.example1">
                <title>Declaring a table class with explicit table name</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';
}

?>]]></programlisting>
            </example>

            <para>
                If you don't specify the table name, it defaults to the name
                of the class.  If you rely on this default, the class name
                must match the spelling of the table name as it appears in
                the database.
            </para>

            <example id="zend.db.table.defining.table-schema.example">
                <title>Declaring a table class with implicit table name</title>
                <programlisting role="php"><![CDATA[<?php

class bugs extends Zend_Db_Table_Abstract
{
    // table name matches class name
}

?>]]></programlisting>
            </example>

            <para>
                You can also declare the schema for the table in the protected
                variable <code>$_schema</code>.
                In some RDBMS brands, the term for this is database or
                tablespace, but it is used similarly.
                You can also declare the schema as part of the table string.
            </para>

            <example id="zend.db.table.defining.table-schema.example3">
                <title>Declaring a table class with schema</title>
                <programlisting role="php"><![CDATA[<?php

// First alternative:

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_schema = 'bug_db';
    protected $_name = 'bugs';
}

// Second alternative:

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bug_db.bugs';
}

?>]]></programlisting>
            </example>

            <para>
                If you don't specify the schema name, it defaults to the
                schema to which your database adapter instance is connected.
            </para>

        </sect3>

        <sect3 id="zend.db.table.defining.primary-key">

            <title>Defining the Table Primary Key</title>

            <para>
                Every table should have a primary key.  You can declare the
                column for the primary key using the protected variable
                <code>$_primary</code>.
                This is either a string that names the single column for the
                primary key, or else it is an array of column names if your
                primary key is a compound key.
            </para>

            <example id="zend.db.table.defining.primary-key.example">
                <title>Example of specifying the primary key</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';
    protected $_primary = 'bug_id';
}

?>]]></programlisting>
            </example>

            <para>
                If you don't specify the primary key, Zend_Db_Table_Abstract
                tries to discover the primary key based on the information 
                provided by the <code>describeTable()</code> method.
            </para>

        </sect3>

        <sect3 id="zend.db.table.defining.setup">

            <title>Overriding Table Setup Methods</title>

            <para>
                When you create an instance of a Table class, the constructor
                calls a set of protected methods that initialize metadata
                for the table.  You can extend any of these methods to define
                metadata explicitly.  Remember to call the parent's method
                when you are done.
            </para>

            <example id="zend.db.table.defining.setup.example">
                <title>Example of overriding the _setupTableName() method</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected function _setupTableName()
    {
        $this->_name = 'bugs';
        parent::_setupTableName();
    }
}

?>]]></programlisting>
            </example>

            <para>
                The setup methods you can override are the following:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <code>_setupDatabaseAdapter()</code>
                        checks that an adapter has been provided;
                        gets a default adapter from the registry
                        if needed. By overriding this method, you can
                        set a database adapter from some other source.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>_setupTableName()</code>
                        defaults the table name to the name of the class.
                        By overriding this method, you can set the table name
                        before this default behavior runs.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>_setupMetadata()</code>
                        sets the schema if the table name contains the 
                        pattern "schema.table";
                        calls <code>describeTable()</code> to get metadata
                        information; defaults the <code>$_cols</code>
                        array to the columns reported by
                        <code>describeTable()</code>.
                        By overriding this method, you can specify the columns.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>_setupPrimaryKey()</code>
                        defaults the primary key columns to those reported
                        by <code>describeTable()</code>; checks that the
                        primary key columns are included in the
                        <code>$_cols</code> array.
                        By overriding this method, you can specify the primary
                        key columns.
                    </para>
                </listitem>
            </itemizedlist>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.constructing">

        <title>Creating an Instance of a Table</title>

        <para>
            Before you use a Table class, create an instance using its 
            constructor.  The constructor's argument is an array of options.
            The most important option to a Table constructor is the
            database adapter instance, representing a live connection
            to an RDBMS.  There are three ways of specifying the database
            adapter to a Table class, and these three ways are described
            below:
        </para>

        <sect3 id="zend.db.table.constructing.adapter">

            <title>Specifying a Database Adapter</title>

            <para>
                The first way to provide a database adapter to a Table class
                is by passing it as an object of type Zend_Db_Adapter_Abstract
                in the options array, identified by the key <code>'db'</code>.
            </para>

            <example id="zend.db.table.constructing.adapter.example">
                <title>Example of constructing a Table using an Adapter object</title>
                <programlisting role="php"><![CDATA[<?php

$db = Zend_Db::factory('PDO_MYSQL', $options);

$table = new Bugs(array('db' => $db));

?>]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.constructing.default-adapter">

            <title>Setting a Default Database Adapter</title>

            <para>
                The second way to provide a database adapter to a Table class
                is by declaring an object of type Zend_Db_Adapter_Abstract
                to be a default database adapter for all subsequent instances
                of Tables in your application.  You can do this with the static
                method <code>Zend_Db_Table_Abstract::setDefaultAdapter()</code>.
                The argument is an object of type Zend_Db_Adapter_Abstract.
            </para>

            <example id="zend.db.table.constructing.default-adapter.example">
                <title>Example of constructing a Table using a the Default Adapter</title>
                <programlisting role="php"><![CDATA[<?php

$db = Zend_Db::factory('PDO_MYSQL', $options);
Zend_Db_Table_Abstract::setDefaultAdapter($db);

// Later...

$table = new Bugs();

?>]]></programlisting>
            </example>

            <para>
                It can be convenient to create the database adapter
                object in a central place of your application, such as
                the bootstrap, and then store it as the default adapter.
                This gives you a means to ensure that the
                adapter instance is the same throughout your application.
                However, setting a default adapter is limited to a
                single adapter instance.
            </para>

        </sect3>


        <sect3 id="zend.db.table.constructing.registry">

            <title>Storing a Database Adapter in the Registry</title>

            <para>
                The third way to provide a database adapter to a Table class
                is by passing a string in the options array, also identified
                by the <code>'db'</code> key.  The string is used as a key
                to the static Zend_Registry instance, where the entry at
                that key is an object of type Zend_Db_Adapter_Abstract.
            </para>

            <example id="zend.db.table.constructing.registry.example">
                <title>Example of constructing a Table using a Registry key</title>
                <programlisting role="php"><![CDATA[<?php

$db = Zend_Db::factory('PDO_MYSQL', $options);
Zend_Registry::set('my_db', $db);

// Later...

$table = new Bugs(array('db' => 'my_db'));

?>]]></programlisting>
            </example>

            <para>
                Like setting the default adapter, this gives you the means
                to ensure that the same adapter instance is used throughout
                your application.  Using the registry is more flexible,
                because you can store more than one adapter instance.
                A given adapter instance is specific to a certain RDBMS brand
                and database instance.  If your application needs access
                to multiple databases or even multiple database brands,
                then you need to use multiple adapters.
            </para>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.insert">

        <title>Inserting Rows to a Table</title>

        <para>
            You can use the Table object to insert rows into the database
            table on which the Table object is based.  Use the
            <code>insert()</code> method of your Table object.
            The argument is an associative array, mapping column names to
            values.
        </para>

        <example id="zend.db.table.insert.example">
            <title>Example of inserting to a Table</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$data = array(
    'created_on'      => '2007-03-22',
    'bug_description' => 'Something wrong',
    'bug_status'      => 'NEW'
);

$table->insert($data);

?>]]></programlisting>
        </example>

        <para>
            By default, the values in your data array are inserted as
            literal values, using parameters.  If you need them to be 
            treated as SQL expressions, you must make sure they are distinct
            from plain strings.  Use an object of type Zend_Db_Expr to do this.
        </para>

        <example id="zend.db.table.insert.example-expr">
            <title>Example of inserting expressions to a Table</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$data = array(
    'created_on'      => new Zend_Db_Expr('CURDATE()'),
    'bug_description' => 'Something wrong',
    'bug_status'      => 'NEW'
);

?>]]></programlisting>
        </example>

        <para>
            In the examples of inserting rows above, it is assumed that the
            table has an auto-incrementing primary key.  This is the default
            behavior of Zend_Db_Table_Abstract, but there are other types
            of primary keys as well.  The following sections describe how to
            support different types of primary keys.
        </para>

        <sect3 id="zend.db.table.insert.key-auto">

            <title>Using a Table with an Auto-incrementing Key</title>

            <para>
                An auto-incrementing primary key generates a unique integer
                value for you if you omit the primary key column from your
                SQL <code>INSERT</code> statement.
            </para>

            <para>
                In Zend_Db_Table_Abstract, if you define the protected
                variable <code>$_sequence</code> to be the Boolean value
                <code>true</code>, then the class assumes that the table
                has an auto-incrementing primary key.
            </para>

            <example id="zend.db.table.insert.key-auto.example">
                <title>Example of declaring a Table with auto-incrementing primary key</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    // This is the default in the Zend_Db_Table_Abstract class;
    // you do not need to define this.
    protected $_sequence = true;
}

?>]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.insert.key-sequence">

            <title>Using a Table with a Sequence</title>

            <note>
                <para>
                    Support for natural keys is not implemented in
                    Zend_Db_Table in the current version;
                    the proposed usage below does not work yet,
                    but it is planned for Zend Framework 1.0.
                </para>
            </note>

            <para>
                A sequence is a database object that generates a unique
                value, which can be used as a primary key value in one or
                more tables of the database.
            </para>

            <para>
                If you define <code>$_sequence</code> to be a string,
                then Zend_Db_Table_Abstract assumes the string to name
                a sequence object in the database.  The sequence is invoked
                to generate a new value, and this value is used in the
                <code>INSERT</code> operation.
            </para>

            <example id="zend.db.table.insert.key-sequence.example">
                <title>Example of declaring a Table with a sequence</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    protected $_sequence = 'bug_sequence';
}

?>]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.insert.key-natural">

            <title>Using a Table with a Natural Key</title>

            <note>
                <para>
                    Support for natural keys is not implemented in
                    Zend_Db_Table in the current version;
                    the proposed usage below does not work yet,
                    but it is planned for Zend Framework 1.0.
                </para>
            </note>

            <para>
                Some tables have a natural key.  This means that the key is
                not automatically generated by the table or by a sequence.
                You must specify the value for the primary key in this case.
            </para>

            <para>
                If you define the <code>$_sequence</code> to be the Boolean
                value <code>false</code>, then Zend_Db_Table_Abstract assumes
                that the table has a natural primary key.  You must provide
                values for the primary key columns in the array of data to the
                <code>insert()</code> method, or else this method throws a
                Zend_Db_Table_Exception.
            </para>

            <example id="zend.db.table.insert.key-natural.example">
                <title>Example of declaring a Table with a natural key</title>
                <programlisting role="php"><![CDATA[<?php

class BugStatus extends Zend_Db_Table_Abstract
{
    protected $_name = 'bug_status';

    protected $_sequence = false;
}

?>]]></programlisting>
            </example>

            <note>
                <para>
                    All RDBMS brands support tables with natural keys.
                    Examples of tables that are often declared as having
                    natural keys are lookup tables, intersection tables
                    in many-to-many relationships, or most tables with
                    compound primary keys.
                </para>
            </note>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.update">

        <title>Updating Rows in a Table</title>

        <para>
            You can update rows in a database table using the
            <code>update</code> method of a Table class.  This method
            takes two arguments:  an associative array of columns to change
            and new values to assign to these columns; and an SQL expression
            that is used in a <code>WHERE</code> clause, as criteria for
            the rows to change in the <code>UPDATE</code> operation.
        </para>

        <example id="zend.db.table.update.example">
            <title>Example of updating rows in a Table</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$data = array(
    'updated_on'      => '2007-03-23',
    'bug_status'      => 'FIXED'
);

$where = $table->getAdapter()->quoteInto('bug_id = ?', 1234);

$table->update($data, $where);

?>]]></programlisting>
        </example>

        <para>
            The second argument can be an array of SQL expressions.
            The expressions are combined as Boolean terms
            using an <code>AND</code> operator.
        </para>

        <note>
            <para>
                The values and identifiers in the SQL expression are not
                quoted for you.  If you have values or identifiers that
                require quoting, you are responsible for doing this.
                Use the <code>quote()</code>, <code>quoteInto()</code>, and
                <code>quoteIdentifier()</code> methods of the database adapter.
            </para>
        </note>

    </sect2>

    <sect2 id="zend.db.table.delete">

        <title>Deleting Rows from a Table</title>

        <para>
            You can delete rows from a database table using the
            <code>delete()</code> method.  This method takes one argument,
            which is an SQL expression that is used in a <code>WHERE</code>
            clause, as criteria for the rows to delete.
        </para>

        <example id="zend.db.table.delete.example">
            <title>Example of deleting rows from a Table</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where = $table->getAdapter()->quoteInto('bug_id = ?', 1235);

$table->delete($where);

?>]]></programlisting>
        </example>

        <para>
            The second argument can be an array of SQL expressions.
            The expressions are combined as Boolean terms
            using an <code>AND</code> operator.
        </para>

        <note>
            <para>
                The values and identifiers in the SQL expression are not
                quoted for you.  If you have values or identifiers that
                require quoting, you are responsible for doing this.
                Use the <code>quote()</code>, <code>quoteInto()</code>, and
                <code>quoteIdentifier()</code> methods of the database adapter.
            </para>
        </note>

    </sect2>

    <sect2 id="zend.db.table.find">

        <title>Finding Rows by Primary Key</title>

        <para>
            You can query the database table for rows matching specific values
            in the primary key, using the <code>find()</code> method.
            The first argument of this method is either a single value or
            an array of values to match against the primary key of the
            table.
        </para>

        <example id="zend.db.table.find.example">
            <title>Example of finding rows by primary key values</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

// Find a single row
// Returns a Rowset
$rows = $table->find(1234);

// Find multiple rows
// Also returns a Rowset
$rows = $table->find(array(1234, 5678));

?>]]></programlisting>
        </example>

        <para>
            If you specify a single value, the method returns at most
            one row, because a primary key cannot have duplicate values
            and there is at most one row in the database table matching the
            value you specify.  If you specify multiple values in an array,
            the method returns at most as many rows as the number of distinct
            values you specify.
        </para>

        <para>
            The <code>find()</code> method might return fewer rows than
            the number of values you specify for the primary key, if some
            of the values don't match any rows in the database table.
            The method even may return zero rows.  Because the number of
            rows returned is variable, the <code>find()</code> method returns
            an object of type Zend_Db_Table_Rowset_Abstract.
        </para>

        <para>
            If the primary key is a compound key, that is, it consists
            of multiple columns, you can specify the additional columns as
            additional arguments to the <code>find()</code> method.
            You must provide as many arguments as the number of columns in
            the table's primary key.
        </para>

        <para>
            To find multiple rows from a table with a compound primary key,
            provide an array for each of the arguments.  All of these arrays
            must have the same number of elements.
        </para>

        <example id="zend.db.table.find.example-compound">
            <title>Example of finding rows by compound primary key values</title>
            <programlisting role="php"><![CDATA[<?php

class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs_products';
    protected $_primary = array('bug_id', 'product_id');
}

$table = new BugsProducts();

// Find a single row with a compound primary key
// Returns a Rowset
$rows = $table->find(1234, 'ABC');

// Find multiple rows with compound primary keys
// Also returns a Rowset
$rows = $table->find(array(1234, 5678), array('ABC', 'DEF'));

?>]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.db.table.fetch-all">

        <title>Querying for a Set of Rows</title>

        <para>
            You can query for a set of rows using any criteria other than
            the primary key values, using the <code>fetchAll()</code> method
            of the Table class.  This method returns an object of type
            Zend_Db_Table_Rowset_Abstract.
        </para>

        <example id="zend.db.table.fetch-all.example1">
            <title>Example of finding rows by an expression</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW');

$rows = $table->fetchAll($where);

?>]]></programlisting>
        </example>

        <para>
            The first argument to this method is an SQL expression that
            is used in a <code>WHERE</code> clause, like those used in the
            <code>update()</code> and <code>delete()</code> methods 
            described earlier.
        </para>

        <note>
            <para>
                The values and identifiers in the SQL expression are not
                quoted for you.  If you have values or identifiers that
                require quoting, you are responsible for doing this.
                Use the <code>quote()</code>, <code>quoteInto()</code>, and
                <code>quoteIdentifier()</code> methods of the database adapter.
            </para>
        </note>

        <para>
            The second argument is an expression or array of expressions
            used as sorting criteria in an <code>ORDER BY</code> clause.
        </para>

        <para>
            The third and fourth arguments are the count and offset integer
            values, used to make the query return a specific subset of rows.
            These values are used in a <code>LIMIT</code> clause, or in
            equivalent logic for RDBMS brands that do not support the
            <code>LIMIT</code> syntax.
        </para>

        <example id="zend.db.table.fetch-all.example2">
            <title>Example of finding rows by an expression</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where  = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW');

$order  = 'bug_id';

// Return the 21st through 30th rows
$count  = 10;
$offset = 20;

$rows = $table->fetchAll($where, $order, $count, $offset);

?>]]></programlisting>
        </example>

        <para>
            All of the arguments above are optional.  If you omit these
            arguments, the result set includes all rows from the table
            in an unpredictable order.
        </para>

    </sect2>

    <sect2 id="zend.db.table.fetch-row">

        <title>Querying for a Single Row</title>

        <para>
            You can query for a single row using any criteria other than
            the primary key values, using the <code>fetchRow()</code> method
            of the Table class.  Usage of this method is similar to that
            of the <code>fetchAll()</code> method, in that its arguments
            include the <code>WHERE</code> expression and the sorting criteria.
        </para>

        <example id="zend.db.table.fetch-row.example1">
            <title>Example of finding a single row by an expression</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where  = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW');

$order  = 'bug_id';

$row = $table->fetchRow($where, $order);

?>]]></programlisting>
        </example>

        <para>
            This method returns an object of type Zend_Db_Table_Row_Abstract.
            If the search criteria you specified match no rows in the 
            database table, then <code>fetchRow()</code> returns PHP's
            <code>null</code> value.
        </para>

    </sect2>

    <sect2 id="zend.db.table.info">

        <title>Retrieving Table Metadata Information</title>

        <para>
            The Zend_Db_Table_Abstract class provides some information
            about its metadata.  The <code>info()</code> method returns
            an array structure with information about the table, its
            columns and primary key, and other metadata.
        </para>

        <example id="zend.db.table.info.example">
            <title>Example of getting the table name</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$info = $table->info();

echo "The table name is " . $info['name'] . "\n";

?>]]></programlisting>
        </example>

        <para>
            The keys of the array returned by the <code>info()</code>
            method are described below:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="strong">name</emphasis> =>
                    the name of the table.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">cols</emphasis> =>
                    an array, naming the column(s) of the table.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">primary</emphasis> =>
                    an array, naming the column(s) in the primary key.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">metadata</emphasis> =>
                    an associative array, mapping column names to
                    information about the columns.  This is the information
                    returned by the <code>describeTable()</code> method.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">rowClass</emphasis> =>
                    the name of the concrete class used for Row objects
                    returned by methods of this table instance.
                    This defaults to Zend_Db_Table_Row.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">rowsetClass</emphasis> =>
                    the name of the concrete class used for Rowset objects
                    returned by methods of this table instance.
                    This defaults to Zend_Db_Table_Rowset.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">referenceMap</emphasis> =>
                    an associative array, with information about
                    references from this table to any parent tables.
                    See <xref linkend="zend.db.table.relationships.defining" />.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">dependentTables</emphasis> =>
                    an array of class names of tables that reference this table.
                    See <xref linkend="zend.db.table.relationships.defining" />.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">schema</emphasis> =>
                    the name of the schema (or database or tablespace)
                    for this table.
                </para>
            </listitem>
        </itemizedlist>

    </sect2>

    <sect2 id="zend.db.table.extending">

        <title>Customizing and Extending a Table Class</title>

        <sect3 id="zend.db.table.extending.row-rowset">

            <title>Using Custom Row or Rowset Classes</title>

            <para>
                By default, methods of the Table class return a
                Rowset in instances of the concrete class
                Zend_Db_Table_Rowset, and Rowsets contain a
                collection of instances of the concrete class
                Zend_Db_Table_Row.  You can specify an alternative
                class to use for either of these, but they must
                be classes that extend Zend_Db_Table_Rowset_Abstract
                and Zend_Db_Table_Row_Abstract, respectively.
            </para>

            <para>
                You can specify Row and Rowset classes using the
                Table constructor's options array, in keys
                <code>'rowClass'</code> and
                <code>'rowsetClass'</code> respectively.
                Specify the names of the classes using strings.
            </para>

            <example id="zend.db.table.extending.row-rowset.example">
                <title>Example of specifying the Row and Rowset classes</title>
                <programlisting role="php"><![CDATA[<?php

class My_Row extends Zend_Db_Table_Row_Abstract
{
    ...
}

class My_Rowset extends Zend_Db_Table_Rowset_Abstract
{
    ...
}

$table = new Bugs(
    array(
        'rowClass'    => 'My_Row',
        'rowsetClass' => 'My_Rowset'
    )
);

$where = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW')

// Returns an object of type My_Rowset,
// containing an array of objects of type My_Row.
$rows = $table->fetchAll($where);

?>]]></programlisting>
            </example>

            <para>
                You can change the classes by specifying
                them with the <code>setRowClass()</code> and
                <code>setRowsetClass()</code> methods.  This applies to
                rows and rowsets created subsequently; it does not change
                the class of any row or rowset objects you have created
                previously.
            </para>

            <example id="zend.db.table.extending.row-rowset.example2">
                <title>Example of changing the Row and Rowset classes</title>
                <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW')

// Returns an object of type Zend_Db_Table_Rowset
// containing an array of objects of type Zend_Db_Table_Row.
$rowsStandard = $table->fetchAll($where);

$table->setRowClass('My_Row');
$table->setRowsetClass('My_Rowset');

// Returns an object of type My_Rowset,
// containing an array of objects of type My_Row.
$rowsCustom = $table->fetchAll($where);

// The $rowsStandard object still exists, and it is unchanged.

?>]]></programlisting>
            </example>

            <para>
                For more information on the Row and Rowset classes,
                see <xref linkend="zend.db.table.row" /> and
                <xref linkend="zend.db.table.rowset" />.
            </para>

        </sect3>

        <sect3 id="zend.db.table.extending.insert-update">

            <title>Defining Custom Logic for Insert and Update</title>

            <para>
                You can override the <code>insert()</code> and
                <code>update()</code> methods in your Table class.
                This gives you the opportunity to implement custom code
                that is executed before performing the database operation.
                Be sure to call the parent class method when you are done.
            </para>

            <example id="zend.db.table.extending.insert-update.example">
                <title>Custom logic to manage timestamps</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    public function insert($data)
    {
        // add a timestamp
        if (empty($data['created_on'])) {
            $data['created_on'] = time();
        }
        return parent::insert($data);
    }

    public function update($data, $where)
    {
        // add a timestamp
        if (empty($data['updated_on'])) {
            $data['updated_on'] = time();
        }
        return parent::update($data, $where);
    }
}

?>]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.extending.finders">

            <title>Define Custom Search Methods</title>

            <para>
                You can implement custom query methods in your Table class,
                if you have frequent need to do queries against this table
                with specific criteria.  Most queries can be written using
                <code>fetchAll()</code>, but this requires that you duplicate
                code to form the query conditions if you need to run the
                query in several places in your application.
                Therefore it can be convenient to implement a method 
                in the Table class to perform frequently-used queries
                against this table.
            </para>

            <example id="zend.db.table.extending.finders.example">
                <title>Custom method to find bugs by status</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    public function findByStatus($status)
    {
        $where = $this->getAdapter()->quoteInto('bug_status = ?', $status);
        return $this->fetchAll($where, 'bug_id');
    }
}

?>]]></programlisting>
            </example>

        </sect3>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
